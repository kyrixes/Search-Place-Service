본 프로젝트는 JAVA8 Gradle 기반 Spring Boot 프로젝트입니다.

기본 요청사항
1. 클라이언트로부터 검색어를 받아 이를 카카오 검색 API와 네이버 검색 API으로 요청, 각 결과를 5개씩 10개를 응답받습니다. 검색 결과는 두 API의 응답값 중 동일한 내용을 최우선으로 하며 다음으로는 카카오의 응답을 우선시 정렬합니다.
2. 해당 서비스를 이용하는 중 언제라도 인기검색어를 조회할 수 있습니다. 인기검색어는 검색된 키워드의 횟수에 따라 내림차순 정렬되어, (키워드, 누적검색횟수)쌍으로 응답됩니다.

상세 구현내용
- 검색 API의 신규 추가를 고려하여 Factory Method 패턴을 활용하였습니다. 신규 API 추가 시 새로운 Concrete Factory를 생성하여 이용할 수 있습니다.
- 데이터 저장소는 레디스를 활용하였습니다. 대용량 트래픽 환경에서는 저장소와의 IO를 줄이는 방법이 선호되어야 하며, 이를 위하여 캐시 기능을 활용할 수 있는 레디스를 선정하였습니다.
- 동시성 이슈: 요구사항 2번의 경우, 만약 해당 키워드와 초기값 0을 Insert 한 후, 해당 키워드의 카운트를 업데이트 하는 방식으로 구현하면 락이 걸릴 수 있어 매우 위험합니다.
	이를 위하여 검색어와 검색 시간을 row로 Insert하며, 검색누적횟수는 Group By를 이용하여 추출합니다. 키워드 별 검색 횟수의 정확도는 캐싱의 유지 시각과 캐시 데이터의 크기에 따라 결정할 수 있습니다.
	번외로, 인기검색어에 대한 Refrest가 이루어지지 않으면 진정한 의미의 최신 트렌드는 의미가 감소하므로, 이는 현업의 Refresh 정책에 따라 구현할 수 있습니다 (집계성 배치 등등).
- 장애 대응을 위하여 resilience4j 라이브러리를 활용하여 서킷 브레이커를 적용하였습니다. 일정 수준 이상으로 의도되지 않은 결과가 발생하는 경우 Fault Tolerance를 유지하며 장애에 대응합니다.

**서비스의 부하가 매우 커지는 경우
- 실시간 대용량 트래픽 서비스에서 가장 피해야 할 점은 단일 장애지점이라고 생각합니다. 이를 위하여 수직 확장이 아닌 수평 확장으로 방향을 잡고 서버를 증설, 로드밸런서를 도입합니다.
	다만 이 때 발생하는 이슈로 사용자의 세션이 끊긴다는 문제가 있는데 이는 세션 클러스터링을 활용함으로 해결할 수 있으며, 최근에는 이를 위하여 In-Memory 방식의 Database 방식을 사용하는 Redis와 Memcached가 사용되고 있습니다.
	

기능의 테스트
- 프로젝트 폴더 최상단의 test.http를 활용하여 진행할 수 있습니다.
- 테스트 진행 전 반드시 resource 폴더 내의 YML 파일 속성을 변경해야합니다. 각 발급 방법은 아래 링크를 따라주시기 바랍니다.
	- 카카오 REST API KEY: https://developers.kakao.com/docs/latest/ko/getting-started/app
	- 네이버 ClientID / Client Secret: https://developers.naver.com/docs/search/blog/
- 테스트는 빈 문자열 테스트와 검색어를 통한 검색 테스트, 그리고 상시 실행해볼 수 있는 인기 검색어 테스트로 구성되어 있습니다

